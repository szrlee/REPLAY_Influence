#!/usr/bin/env python3
"""
Main Runner for REPLAY Influence Analysis
=========================================

This script provides a command-line interface for running MAGIC influence analysis
and LDS validation. It includes comprehensive error handling, configuration validation,
and cleanup utilities.

Python >=3.8 Compatible
"""

import argparse
import warnings
from pathlib import Path
import shutil
import os
import logging
import sys
from typing import Optional, Dict, Any, List
import traceback

# Project-specific imports from src directory
from src import config
from src.utils import setup_logging, set_global_deterministic_state
from src.magic_analyzer import MagicAnalyzer
from src.lds_validator import run_lds_validation


def clean_magic_output_files() -> None:
    """
    Cleans up output files generated by the MAGIC analysis.
    
    Uses atomic operations and comprehensive error handling to ensure
    robust cleanup even if some files are locked or missing.
    
    Raises:
        RuntimeError: If critical cleanup operations fail.
    """
    logger = logging.getLogger('influence_analysis.cleanup')
    logger.info("--- Cleaning MAGIC Analysis Output Files ---")

    cleanup_errors: List[str] = []
    
    # Files to clean based on config and MagicAnalyzer logic
    batch_dict_file = config.BATCH_DICT_FILE
    scores_file = config.get_magic_scores_path(target_idx=config.MAGIC_TARGET_VAL_IMAGE_IDX)
    plot_file = config.MAGIC_PLOTS_DIR / f"magic_influence_val_{config.MAGIC_TARGET_VAL_IMAGE_IDX}.png"

    files_to_delete = [batch_dict_file, scores_file, plot_file]
    
    for f_path in files_to_delete:
        if f_path.exists():
            try:
                os.remove(f_path)
                logger.info(f"Deleted: {f_path}")
            except OSError as e:
                error_msg = f"Error deleting {f_path}: {e.strerror}"
                logger.error(error_msg)
                cleanup_errors.append(error_msg)
        else:
            logger.debug(f"Not found (already clean or not generated): {f_path}")

    # Clean Checkpoints Directory with enhanced error handling
    if config.MAGIC_CHECKPOINTS_DIR.exists() and config.MAGIC_CHECKPOINTS_DIR.is_dir():
        logger.info(f"Cleaning MAGIC checkpoints directory: {config.MAGIC_CHECKPOINTS_DIR}")
        try:
            # Remove all files and subdirectories within MAGIC_CHECKPOINTS_DIR
            for item in config.MAGIC_CHECKPOINTS_DIR.iterdir():
                try:
                    if item.is_dir():
                        shutil.rmtree(item)
                    else:
                        os.remove(item)
                        if item.name.startswith('batch_') and item.suffix == '.pkl':
                            logger.debug(f"Cleaned memory-efficient batch file: {item}")
                except OSError as item_e:
                    error_msg = f"Error deleting {item}: {item_e.strerror}"
                    logger.error(error_msg)
                    cleanup_errors.append(error_msg)
            logger.info(f"Cleaned contents of {config.MAGIC_CHECKPOINTS_DIR}")
        except OSError as e:
            error_msg = f"Error cleaning {config.MAGIC_CHECKPOINTS_DIR}: {e.strerror}"
            logger.error(error_msg)
            cleanup_errors.append(error_msg)
    else:
        logger.debug(f"MAGIC checkpoints directory not found: {config.MAGIC_CHECKPOINTS_DIR}")
    
    if cleanup_errors:
        logger.warning(f"MAGIC cleanup completed with {len(cleanup_errors)} errors")
        if len(cleanup_errors) > 5:  # If too many errors, something is seriously wrong
            raise RuntimeError(f"Too many cleanup errors ({len(cleanup_errors)}). Check permissions and file locks.")
    else:
        logger.info("--- MAGIC Analysis Output Cleaning Finished Successfully ---")


def clean_lds_output_files() -> None:
    """
    Cleans up output files generated by the LDS validation analysis.
    
    Uses comprehensive error handling and atomic operations for robust cleanup.
    
    Raises:
        RuntimeError: If critical cleanup operations fail.
    """
    logger = logging.getLogger('influence_analysis.cleanup')
    logger.info("--- Cleaning LDS Validation Output Files ---")

    cleanup_errors: List[str] = []
    
    # Files to clean based on LDS validator outputs
    files_to_delete = []
    
    # Subset indices file
    if config.LDS_INDICES_FILE and config.LDS_INDICES_FILE.exists():
        files_to_delete.append(config.LDS_INDICES_FILE)
    
    # Plot files - check for correlation plot with target val image index
    plot_file = config.LDS_PLOTS_DIR / f"lds_correlation_val_{config.LDS_TARGET_VAL_IMAGE_IDX_FOR_CORRELATION}.png"
    if plot_file.exists():
        files_to_delete.append(plot_file)
    
    # Delete individual files with error handling
    for f_path in files_to_delete:
        try:
            os.remove(f_path)
            logger.info(f"Deleted: {f_path}")
        except OSError as e:
            error_msg = f"Error deleting {f_path}: {e.strerror}"
            logger.error(error_msg)
            cleanup_errors.append(error_msg)

    # Clean directories with comprehensive error handling
    directories_to_clean = [
        config.LDS_CHECKPOINTS_DIR,
        config.LDS_LOSSES_DIR,
        config.LDS_PLOTS_DIR
    ]
    
    for directory in directories_to_clean:
        if directory.exists() and directory.is_dir():
            logger.info(f"Cleaning LDS directory: {directory}")
            try:
                for item in directory.iterdir():
                    try:
                        if item.is_dir():
                            shutil.rmtree(item)
                        else:
                            os.remove(item)
                    except OSError as item_e:
                        error_msg = f"Error deleting {item}: {item_e.strerror}"
                        logger.error(error_msg)
                        cleanup_errors.append(error_msg)
                logger.info(f"Cleaned contents of {directory}")
            except OSError as e:
                error_msg = f"Error cleaning {directory}: {e.strerror}"
                logger.error(error_msg)
                cleanup_errors.append(error_msg)
        else:
            logger.debug(f"LDS directory not found: {directory}")
    
    if cleanup_errors:
        logger.warning(f"LDS cleanup completed with {len(cleanup_errors)} errors")
        if len(cleanup_errors) > 10:  # If too many errors, something is seriously wrong
            raise RuntimeError(f"Too many cleanup errors ({len(cleanup_errors)}). Check permissions and file locks.")
    else:
        logger.info("--- LDS Validation Output Cleaning Finished Successfully ---")


def validate_runtime_environment() -> Dict[str, Any]:
    """
    Validates the runtime environment and returns system information.
    
    Returns:
        Dict[str, Any]: Environment information.
        
    Raises:
        EnvironmentError: If critical environment requirements are not met.
    """
    logger = logging.getLogger('influence_analysis.main')
    logger.info("Validating runtime environment...")
    
    try:
        env_info = config.validate_environment()
        logger.info("Environment validation passed")
        
        # Log key environment info
        logger.info(f"Python version: {env_info.get('python_version', 'unknown')}")
        logger.info(f"PyTorch version: {env_info.get('torch_version', 'unknown')}")
        logger.info(f"CUDA available: {env_info.get('cuda_available', False)}")
        
        if env_info.get('cuda_available', False):
            logger.info(f"GPU memory: {env_info.get('gpu_memory_gb', 'unknown')} GB")
        
        return env_info
        
    except Exception as e:
        logger.error(f"Environment validation failed: {e}")
        raise EnvironmentError(f"Runtime environment validation failed: {e}") from e


def setup_output_directories() -> None:
    """
    Creates all required output directories with proper error handling.
    
    Raises:
        OSError: If directory creation fails.
    """
    logger = logging.getLogger('influence_analysis.main')
    logger.debug("Creating output directories...")
    
    directories = [
        config.OUTPUTS_DIR,
        config.MAGIC_CHECKPOINTS_DIR,
        config.MAGIC_SCORES_DIR,
        config.MAGIC_PLOTS_DIR,
        config.LDS_CHECKPOINTS_DIR,
        config.LDS_LOSSES_DIR,
        config.LDS_PLOTS_DIR,
    ]
    
    # Add parent directories for files
    if config.LDS_INDICES_FILE:
        directories.append(config.LDS_INDICES_FILE.parent)
    
    for directory in directories:
        try:
            directory.mkdir(parents=True, exist_ok=True)
        except OSError as e:
            raise OSError(f"Failed to create directory {directory}: {e}") from e
    
    logger.debug("All output directories created successfully")


def main() -> int:
    """
    Main entry point for the REPLAY Influence Analysis system.
    
    Returns:
        int: Exit code (0 for success, 1 for error).
    """
    parser = argparse.ArgumentParser(
        description="Run REPLAY Influence Analysis Project (MAGIC and LDS).",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --run_magic                           # Run MAGIC analysis only
  %(prog)s --run_lds                             # Run LDS validation only  
  %(prog)s --run_magic --run_lds                 # Run both analyses
  %(prog)s --run_magic --memory_efficient        # Use memory-efficient mode
  %(prog)s --clean_magic --clean_lds             # Clean all outputs
  %(prog)s --show_config                         # Show configuration and exit
        """
    )
    
    # Analysis options
    parser.add_argument("--run_magic", action="store_true", 
                       help="Run the MAGIC influence analysis.")
    parser.add_argument("--run_lds", action="store_true", 
                       help="Run the LDS validation analysis.")
    
    # Cleanup options
    parser.add_argument("--clean_magic", action="store_true", 
                       help="Clean up output files from a previous MAGIC analysis run.")
    parser.add_argument("--clean_lds", action="store_true", 
                       help="Clean up output files from a previous LDS validation run.")
    
    # MAGIC options
    parser.add_argument("--force_retrain_magic", action="store_true", 
                       help="Force retraining of the MAGIC model and batch collection.")
    parser.add_argument("--force_recompute_magic_scores", action="store_true", 
                       help="Force recomputation of MAGIC influence scores.")
    parser.add_argument("--memory_efficient", action="store_true", 
                       help="Use memory-efficient batch replay (saves memory but may be slower).")
    
    # LDS options
    parser.add_argument("--magic_scores_file_for_lds", type=str, default=None,
                        help="Path to pre-computed MAGIC scores .pkl file for LDS. "
                             "If None, uses default from MAGIC run or config.")
    
    # System options
    parser.add_argument("--log_level", type=str, default="INFO", 
                        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
                        help="Set the logging level")
    parser.add_argument("--log_file", type=str, default=None,
                        help="Optional log file path. If not provided, logs to console only.")
    parser.add_argument("--show_config", action="store_true", 
                        help="Show configuration summary and exit.")

    args = parser.parse_args()

    # Setup logging first
    try:
        logger = setup_logging(log_level=args.log_level, log_file=args.log_file)
        logger.info("=== REPLAY Influence Analysis System Starting ===")
    except Exception as e:
        print(f"Failed to setup logging: {e}", file=sys.stderr)
        return 1
    
    try:
        # Validate environment
        env_info = validate_runtime_environment()
        
        # Validate configuration
        config.validate_config()
        logger.info("Configuration validation passed")
        
        # Show config summary if requested
        if args.show_config:
            print(config.get_config_summary())
            return 0

        # Setup output directories
        setup_output_directories()
        
        # Global seed and deterministic state
        set_global_deterministic_state(config.SEED, enable_deterministic=True)
        logger.info(f"Set global deterministic state with master seed {config.SEED}")
        
        # Suppress non-critical warnings for cleaner output
        warnings.filterwarnings('ignore', category=UserWarning)

        # Handle cleanup operations
        cleanup_performed = False
        
        if args.clean_magic:
            clean_magic_output_files()
            cleanup_performed = True

        if args.clean_lds:
            clean_lds_output_files()
            cleanup_performed = True
        
        # Exit early if only cleanup was requested
        if cleanup_performed and not (args.run_magic or args.run_lds):
            logger.info("Cleanup completed. No analysis requested.")
            return 0

        magic_scores_output_path_for_lds: Optional[Path] = None

        # Run MAGIC Analysis
        if args.run_magic:
            logger.info("--- Running MAGIC Influence Analysis ---")
            try:
                analyzer = MagicAnalyzer(use_memory_efficient_replay=args.memory_efficient)
                
                # 1. Train model and collect states
                total_steps = analyzer.train_and_collect_intermediate_states(
                    force_retrain=args.force_retrain_magic
                )
                
                # Check for valid training steps
                if total_steps <= 0:
                    logger.error(f"Training returned {total_steps} steps. Cannot compute influence scores.")
                    if not args.run_lds:  # Only exit if no LDS to run
                        return 1
                else:
                    # 2. Compute influence scores
                    per_step_scores = analyzer.compute_influence_scores(
                        total_training_iterations=total_steps, 
                        force_recompute=args.force_recompute_magic_scores
                    )
                    
                    # 3. Plot influential images
                    if per_step_scores is not None:
                        try:
                            analyzer.plot_magic_influences(per_step_scores_or_path=per_step_scores)
                        except Exception as plot_e:
                            logger.error(f"Failed to generate MAGIC influence plots: {plot_e}")
                            # Continue execution even if plotting fails
                    else:
                        logger.warning("Skipping MAGIC plotting as scores were not computed or loaded.")
                    
                    # Set path for LDS only if scores were actually computed
                    if per_step_scores is not None:
                        magic_scores_output_path_for_lds = config.get_magic_scores_path(
                            target_idx=config.MAGIC_TARGET_VAL_IMAGE_IDX
                        )
                        # Verify the file actually exists
                        if not magic_scores_output_path_for_lds.exists():
                            logger.warning(f"Expected MAGIC scores file not found: {magic_scores_output_path_for_lds}")
                            magic_scores_output_path_for_lds = None
                
                logger.info("--- MAGIC Influence Analysis Finished ---")
                
            except Exception as magic_e:
                logger.error(f"MAGIC analysis failed with error: {magic_e}")
                logger.debug(f"MAGIC analysis traceback: {traceback.format_exc()}")
                if not args.run_lds:  # Only exit if no LDS to run
                    return 1
                else:
                    logger.warning("Continuing to LDS analysis despite MAGIC failure.")
                    magic_scores_output_path_for_lds = None

        # Run LDS Validation
        if args.run_lds:
            logger.info("--- Running LDS Validation Analysis ---")
            
            try:
                path_to_lds_input_scores: Optional[Path] = None
                
                if args.magic_scores_file_for_lds:
                    path_to_lds_input_scores = Path(args.magic_scores_file_for_lds)
                    if not path_to_lds_input_scores.exists():
                        logger.error(f"Provided MAGIC scores file for LDS not found: {path_to_lds_input_scores}")
                        return 1
                elif magic_scores_output_path_for_lds and magic_scores_output_path_for_lds.exists():
                    # Use path from this session's MAGIC run if available
                    path_to_lds_input_scores = magic_scores_output_path_for_lds
                else:
                    # Fallback to default path from config
                    default_lds_input_path = config.MAGIC_SCORES_FILE_FOR_LDS_INPUT
                    if default_lds_input_path.exists():
                        path_to_lds_input_scores = default_lds_input_path
                    else:
                        logger.error(f"Could not determine MAGIC scores file for LDS. "
                              f"Tried default: {default_lds_input_path}. "
                              f"Please run MAGIC analysis first or specify with --magic_scores_file_for_lds.")
                        return 1

                if path_to_lds_input_scores:
                    # Validate the scores file before passing to LDS
                    try:
                        import pickle
                        with open(path_to_lds_input_scores, 'rb') as f:
                            test_load = pickle.load(f)
                        logger.info(f"Validated MAGIC scores file: {path_to_lds_input_scores}")
                    except Exception as validation_e:
                        logger.error(f"MAGIC scores file appears corrupted: {validation_e}")
                        return 1
                    
                    # Run LDS validation
                    run_lds_validation(precomputed_magic_scores_path=path_to_lds_input_scores)
                else:
                    # This should not be reached due to the logic above, but kept for safety
                    logger.error("Path to MAGIC scores for LDS validation could not be resolved.")
                    return 1

                logger.info("--- LDS Validation Analysis Finished ---")
                
            except Exception as lds_e:
                logger.error(f"LDS validation failed with error: {lds_e}")
                logger.debug(f"LDS validation traceback: {traceback.format_exc()}")
                return 1

        # Check if any analysis was requested
        if not args.run_magic and not args.run_lds and not args.clean_magic and not args.clean_lds:
            logger.error("No analysis or cleanup specified.")
            parser.print_help()
            return 1
        
        logger.info("=== REPLAY Influence Analysis System Completed Successfully ===")
        return 0
        
    except KeyboardInterrupt:
        logger.warning("Analysis interrupted by user")
        return 1
    except Exception as e:
        logger.error(f"Unexpected error in main: {e}")
        logger.debug(f"Main traceback: {traceback.format_exc()}")
        return 1


if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code) 