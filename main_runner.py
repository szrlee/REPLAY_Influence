import argparse
import warnings
from pathlib import Path
import shutil # For rmtree
import os
import logging

# Project-specific imports from src directory
from src import config # Import the whole module for easier access to new path functions
from src.utils import set_seeds, setup_logging
from src.magic_analyzer import MagicAnalyzer # Import the class
from src.lds_validator import run_lds_validation # Still using the function from lds_validator

def clean_magic_output_files():
    """Cleans up output files generated by the MAGIC analysis, updated for new structure."""
    logger = logging.getLogger('influence_analysis.cleanup')
    logger.info("--- Cleaning MAGIC Analysis Output Files (New Structure) ---")

    cleanup_errors = []
    
    # Files and Dirs to clean based on revised config and MagicAnalyzer logic
    batch_dict_file = config.BATCH_DICT_FILE
    # Scores file (per-step) - construct using target_idx from config
    scores_file = config.get_magic_scores_path(target_idx=config.MAGIC_TARGET_VAL_IMAGE_IDX)
    # Plot file - construct using target_idx from config
    plot_file = config.MAGIC_PLOTS_DIR / f"magic_influence_val_{config.MAGIC_TARGET_VAL_IMAGE_IDX}.png" # Match plotting output

    files_to_delete = [batch_dict_file, scores_file, plot_file]
    for f_path in files_to_delete:
        if f_path.exists():
            try:
                os.remove(f_path)
                logger.info(f"Deleted: {f_path}")
            except OSError as e:
                error_msg = f"Error deleting {f_path}: {e.strerror}"
                logger.error(error_msg)
                cleanup_errors.append(error_msg)
        else:
            logger.debug(f"Not found (already clean or not generated): {f_path}")

    # Clean Checkpoints Directory (MAGIC_CHECKPOINTS_DIR)
    if config.MAGIC_CHECKPOINTS_DIR.exists() and config.MAGIC_CHECKPOINTS_DIR.is_dir():
        logger.info(f"Cleaning MAGIC checkpoints directory: {config.MAGIC_CHECKPOINTS_DIR}")
        try:
            # Remove all files and subdirectories within MAGIC_CHECKPOINTS_DIR
            # This includes model checkpoints (sd_*.pt) and batch files (batch_*.pkl) for memory-efficient mode
            for item in config.MAGIC_CHECKPOINTS_DIR.iterdir():
                try:
                    if item.is_dir():
                        shutil.rmtree(item)
                    else:
                        os.remove(item)
                        if item.name.startswith('batch_') and item.suffix == '.pkl':
                            logger.debug(f"Cleaned memory-efficient batch file: {item}")
                except OSError as item_e:
                    error_msg = f"Error deleting {item}: {item_e.strerror}"
                    logger.error(error_msg)
                    cleanup_errors.append(error_msg)
            logger.info(f"Cleaned contents of {config.MAGIC_CHECKPOINTS_DIR}")
        except OSError as e:
            error_msg = f"Error cleaning {config.MAGIC_CHECKPOINTS_DIR}: {e.strerror}"
            logger.error(error_msg)
            cleanup_errors.append(error_msg)
    else:
        logger.debug(f"MAGIC checkpoints directory not found: {config.MAGIC_CHECKPOINTS_DIR}")
    
    if cleanup_errors:
        logger.warning(f"MAGIC cleanup completed with {len(cleanup_errors)} errors")
    else:
        logger.info("--- MAGIC Analysis Output Cleaning Finished Successfully ---")


def clean_lds_output_files():
    """Cleans up output files generated by the LDS validation analysis."""
    logger = logging.getLogger('influence_analysis.cleanup')
    logger.info("--- Cleaning LDS Validation Output Files ---")

    cleanup_errors = []
    
    # Files to clean based on LDS validator outputs
    files_to_delete = []
    
    # Subset indices file
    if config.LDS_INDICES_FILE and config.LDS_INDICES_FILE.exists():
        files_to_delete.append(config.LDS_INDICES_FILE)
    
    # Plot files - check for correlation plot with target val image index
    plot_file = config.LDS_PLOTS_DIR / f"lds_correlation_val_{config.LDS_TARGET_VAL_IMAGE_IDX_FOR_CORRELATION}.png"
    if plot_file.exists():
        files_to_delete.append(plot_file)
    
    # Delete individual files
    for f_path in files_to_delete:
        try:
            os.remove(f_path)
            logger.info(f"Deleted: {f_path}")
        except OSError as e:
            error_msg = f"Error deleting {f_path}: {e.strerror}"
            logger.error(error_msg)
            cleanup_errors.append(error_msg)

    # Clean LDS Checkpoints Directory
    if config.LDS_CHECKPOINTS_DIR.exists() and config.LDS_CHECKPOINTS_DIR.is_dir():
        logger.info(f"Cleaning LDS checkpoints directory: {config.LDS_CHECKPOINTS_DIR}")
        try:
            for item in config.LDS_CHECKPOINTS_DIR.iterdir():
                try:
                    if item.is_dir():
                        shutil.rmtree(item)
                    else:
                        os.remove(item)
                except OSError as item_e:
                    error_msg = f"Error deleting {item}: {item_e.strerror}"
                    logger.error(error_msg)
                    cleanup_errors.append(error_msg)
            logger.info(f"Cleaned contents of {config.LDS_CHECKPOINTS_DIR}")
        except OSError as e:
            error_msg = f"Error cleaning {config.LDS_CHECKPOINTS_DIR}: {e.strerror}"
            logger.error(error_msg)
            cleanup_errors.append(error_msg)
    else:
        logger.debug(f"LDS checkpoints directory not found: {config.LDS_CHECKPOINTS_DIR}")

    # Clean LDS Losses Directory
    if config.LDS_LOSSES_DIR.exists() and config.LDS_LOSSES_DIR.is_dir():
        logger.info(f"Cleaning LDS losses directory: {config.LDS_LOSSES_DIR}")
        try:
            for item in config.LDS_LOSSES_DIR.iterdir():
                try:
                    if item.is_dir():
                        shutil.rmtree(item)
                    else:
                        os.remove(item)
                except OSError as item_e:
                    error_msg = f"Error deleting {item}: {item_e.strerror}"
                    logger.error(error_msg)
                    cleanup_errors.append(error_msg)
            logger.info(f"Cleaned contents of {config.LDS_LOSSES_DIR}")
        except OSError as e:
            error_msg = f"Error cleaning {config.LDS_LOSSES_DIR}: {e.strerror}"
            logger.error(error_msg)
            cleanup_errors.append(error_msg)
    else:
        logger.debug(f"LDS losses directory not found: {config.LDS_LOSSES_DIR}")

    # Clean LDS Plots Directory
    if config.LDS_PLOTS_DIR.exists() and config.LDS_PLOTS_DIR.is_dir():
        logger.info(f"Cleaning LDS plots directory: {config.LDS_PLOTS_DIR}")
        try:
            for item in config.LDS_PLOTS_DIR.iterdir():
                try:
                    if item.is_dir():
                        shutil.rmtree(item)
                    else:
                        os.remove(item)
                except OSError as item_e:
                    error_msg = f"Error deleting {item}: {item_e.strerror}"
                    logger.error(error_msg)
                    cleanup_errors.append(error_msg)
            logger.info(f"Cleaned contents of {config.LDS_PLOTS_DIR}")
        except OSError as e:
            error_msg = f"Error cleaning {config.LDS_PLOTS_DIR}: {e.strerror}"
            logger.error(error_msg)
            cleanup_errors.append(error_msg)
    else:
        logger.debug(f"LDS plots directory not found: {config.LDS_PLOTS_DIR}")
    
    if cleanup_errors:
        logger.warning(f"LDS cleanup completed with {len(cleanup_errors)} errors")
    else:
        logger.info("--- LDS Validation Output Cleaning Finished Successfully ---")


def main():
    parser = argparse.ArgumentParser(description="Run Influence Analysis Project (MAGIC and LDS).")
    parser.add_argument("--run_magic", action="store_true", help="Run the MAGIC influence analysis.")
    parser.add_argument("--run_lds", action="store_true", help="Run the LDS validation analysis.")
    parser.add_argument("--clean_magic", action="store_true", help="Clean up output files from a previous MAGIC analysis run.")
    parser.add_argument("--clean_lds", action="store_true", help="Clean up output files from a previous LDS validation run.")
    
    # Args for MAGIC
    parser.add_argument("--force_retrain_magic", action="store_true", help="Force retraining of the MAGIC model and batch collection.")
    parser.add_argument("--force_recompute_magic_scores", action="store_true", help="Force recomputation of MAGIC influence scores.")
    parser.add_argument("--memory_efficient", action="store_true", help="Use memory-efficient batch replay (saves memory but may be slower).")
    
    # Args for LDS
    parser.add_argument("--magic_scores_file_for_lds", type=str, default=None,
                        help="Path to pre-computed MAGIC scores .pkl file for LDS. "
                             "If None, uses default from MAGIC run or config.")
    
    # Logging and debugging options
    parser.add_argument("--log_level", type=str, default="INFO", 
                        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
                        help="Set the logging level")
    parser.add_argument("--log_file", type=str, default=None,
                        help="Optional log file path. If not provided, logs to console only.")
    parser.add_argument("--show_config", action="store_true", 
                        help="Show configuration summary and exit.")

    args = parser.parse_args()

    # Setup logging
    logger = setup_logging(log_level=args.log_level, log_file=args.log_file)
    
    # Validate configuration
    try:
        config.validate_config()
        logger.info("Configuration validation passed")
    except ValueError as e:
        logger.error(f"Configuration validation failed: {e}")
        return 1
    
    # Show config summary if requested
    if args.show_config:
        print(config.get_config_summary())
        return 0

    # Ensure all output directories are set up first (from original config.py, may need adjustment if removed)
    # config.ensure_output_dirs_exist() # This function was removed from the revised config.py
    # Directories are now created by the analyzer/validator classes or within config path getters for clarity.
    # For safety, can call them here if needed, or rely on individual components.
    logger.debug("Creating output directories...")
    try:
        config.OUTPUTS_DIR.mkdir(parents=True, exist_ok=True)
        config.MAGIC_CHECKPOINTS_DIR.mkdir(parents=True, exist_ok=True)
        config.MAGIC_SCORES_DIR.mkdir(parents=True, exist_ok=True)
        config.MAGIC_PLOTS_DIR.mkdir(parents=True, exist_ok=True)
        config.LDS_CHECKPOINTS_DIR.mkdir(parents=True, exist_ok=True)
        config.LDS_LOSSES_DIR.mkdir(parents=True, exist_ok=True)
        config.LDS_PLOTS_DIR.mkdir(parents=True, exist_ok=True)
        if config.LDS_INDICES_FILE: # It's a Path object
            config.LDS_INDICES_FILE.parent.mkdir(parents=True, exist_ok=True)
    except OSError as dir_e:
        logger.error(f"Failed to create output directories: {dir_e}")
        return 1

    # Global seed and warnings
    set_seeds(config.SEED) # Set seed once at the top
    logger.info(f"Set random seed to {config.SEED}")
    warnings.filterwarnings('ignore')

    # Handle cleanup operations
    cleanup_performed = False
    
    if args.clean_magic:
        clean_magic_output_files()
        cleanup_performed = True

    if args.clean_lds:
        clean_lds_output_files()
        cleanup_performed = True
    
    # Exit early if only cleanup was requested (no analysis to run)
    if cleanup_performed and not (args.run_magic or args.run_lds):
        return 0

    magic_scores_output_path_for_lds = None # Path to scores produced by MagicAnalyzer

    if args.run_magic:
        logger.info("--- Running MAGIC Influence Analysis (Class Based) ---")
        try:
            analyzer = MagicAnalyzer(use_memory_efficient_replay=args.memory_efficient)
            
            # 1. Train model and collect states
            total_steps = analyzer.train_and_collect_intermediate_states(
                force_retrain=args.force_retrain_magic
            )
            
            # Check for valid training steps
            if total_steps <= 0:
                logger.error(f"Training returned {total_steps} steps. Cannot compute influence scores.")
                if not args.run_lds:  # Only exit if no LDS to run
                    return 1
            else:
                # 2. Compute influence scores
                per_step_scores = analyzer.compute_influence_scores(
                    total_training_iterations=total_steps, 
                    force_recompute=args.force_recompute_magic_scores
                )
                
                # 3. Plot influential images (using the per-step scores, plotting function sums them)
                if per_step_scores is not None:
                    try:
                        analyzer.plot_magic_influences(per_step_scores_or_path=per_step_scores)
                    except Exception as plot_e:
                        logger.error(f"Failed to generate MAGIC influence plots: {plot_e}")
                        # Continue execution even if plotting fails
                else:
                    logger.warning("Skipping MAGIC plotting as scores were not computed or loaded.")
                
                # Set path for LDS only if scores were actually computed
                if per_step_scores is not None:
                    magic_scores_output_path_for_lds = config.get_magic_scores_path(
                        target_idx=config.MAGIC_TARGET_VAL_IMAGE_IDX
                    )
                    # Verify the file actually exists
                    if not magic_scores_output_path_for_lds.exists():
                        logger.warning(f"Expected MAGIC scores file not found: {magic_scores_output_path_for_lds}")
                        magic_scores_output_path_for_lds = None
            
            logger.info("--- MAGIC Influence Analysis Finished ---")
            
        except Exception as magic_e:
            logger.error(f"MAGIC analysis failed with error: {magic_e}")
            if not args.run_lds:  # Only exit if no LDS to run
                return 1
            else:
                logger.warning("Continuing to LDS analysis despite MAGIC failure.")
                magic_scores_output_path_for_lds = None

    if args.run_lds:
        logger.info("--- Running LDS Validation Analysis ---")
        
        try:
            path_to_lds_input_scores = None
            if args.magic_scores_file_for_lds:
                path_to_lds_input_scores = Path(args.magic_scores_file_for_lds)
                if not path_to_lds_input_scores.exists():
                    logger.error(f"Provided MAGIC scores file for LDS not found: {path_to_lds_input_scores}")
                    return 1
            elif magic_scores_output_path_for_lds and magic_scores_output_path_for_lds.exists():
                # Use path from this session's MAGIC run if available
                path_to_lds_input_scores = magic_scores_output_path_for_lds
            else:
                # Fallback to default path from config
                default_lds_input_path = config.MAGIC_SCORES_FILE_FOR_LDS_INPUT
                if default_lds_input_path.exists():
                    path_to_lds_input_scores = default_lds_input_path
                else:
                    logger.error(f"Error: Could not determine MAGIC scores file for LDS. "
                          f"Tried default: {default_lds_input_path}. "
                          f"Please run MAGIC analysis first or specify with --magic_scores_file_for_lds.")
                    return 1

            if path_to_lds_input_scores:
                # Validate the scores file before passing to LDS
                try:
                    import pickle
                    with open(path_to_lds_input_scores, 'rb') as f:
                        test_load = pickle.load(f)
                    logger.info(f"Validated MAGIC scores file: {path_to_lds_input_scores}")
                except Exception as validation_e:
                    logger.error(f"MAGIC scores file appears corrupted: {validation_e}")
                    return 1
                
                # run_lds_validation expects a path. It will handle loading and summing per-step scores.
                run_lds_validation(precomputed_magic_scores_path=path_to_lds_input_scores)
            else:
                # This should not be reached due to the logic above, but kept for safety
                logger.error("Error: Path to MAGIC scores for LDS validation could not be resolved.")
                return 1

            logger.info("--- LDS Validation Analysis Finished ---")
            
        except Exception as lds_e:
            logger.error(f"LDS validation failed with error: {lds_e}")
            return 1

    if not args.run_magic and not args.run_lds and not args.clean_magic and not args.clean_lds:
        logger.error("No analysis or cleanup specified. Use --run_magic, --run_lds, --clean_magic, or --clean_lds.")
        parser.print_help()
        return 1
    
    return 0

if __name__ == "__main__":
    exit_code = main()
    exit(exit_code) 